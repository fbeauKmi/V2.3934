
## adaptive Heat soak
# version: 3.0.3
# changelog :
#   -V 1.0 : adaptive bed soak initial release
#   -V 2.0 : adaptive heatsoak for bed, chamber, extruder, Async mode only (can be use only while Printing)
#   -V 2.0.1 : Fix while temperature > target + 2°, add default timeout 30min for heater (avoid interrupt during heating)
#   -V 2.0.2 : allow standalone mode
#   -V 2.0.3 : Fix issues "Must home first" and "unpredictables moves"
#   -V 2.0.4 : Fix "Sequence doesn't reset at startup"
#   -V 2.0.5 : Add OUTPUT_GCODE
#   -V 2.0.6 : Use print_stats instead of virtual_sdcard
#   -V 2.0.7 : add TIMEOUT per sequence
#   -V 2.0.8 : !! `heat` type added it replaces `temp` for heaters. it heat up heater before check temp. add interrupt message.
#              No more need to override CANCEL_PRINT. add HEATSOAK TARGET=<value>
#   -V 2.0.9 : Rparam SEQUENCE load alternate sequence, add tempramp, fix timer accuracy & heater_generic use
#   -V 3.0 :  HEATSOAK become HEATSEQ
#   -V 3.0.1 : TARGET => deprecated , update sequence by command instead
#   -V 3.0.2 : add CLEAR_PAUSE for standalone mode
#   -V 3.0.3 : Fix `timer` type TIMEOUT

# !WARNING! Even in standalone mode you cannot use HEATSEQ inside a macro. It uses Resume/Pause/Delayed_gcode mecanisms
# and yields unpredictable behavior

# Note :
# These macros intents to set heaters target to adapt heatsoak of 3D printer and use bed power stability to 
# determine best soak duration. It was tested on a Voron 2.4 300 mm printer

# Installation :
#  copy heatseq.cfg in your config folder, add an include [include <YOUR_PATH/heatseq.cfg] in
#  your printer.cfg
#  In order to benefit of the async mod you can use HEATSEQ_NEXT/HEATSEQ_CANCEL macros or 
#  modify/override RESUME macro
#  RESUME could be like this

#  [gcode_macro RESUME]
#  rename_existing: RESUME_BASE
#  gcode:
#    {% if printer.pause_resume.is_paused %}
#     {% if printer['gcode_macro HEATSEQ'].soak_pending %}
#      HEATSEQ_NEXT
#     {% else %}
#      ... YOUR CODE HERE ...
#      RESUME_BASE
#     {% endif %}
#    {% endif %}

# Usage:
# WARNING : HEATSEQ MUST NOT BE INCLUDED IN PRINT_START MACRO
# As it uses PAUSE/RESUME sequence it would yield to unpredictible behavior if included in start_print
#   HEATSEQ SEQUENCE=<sequence_name> <sequence_item>=<target_temp> <sequence_item>_TIMEOUT=<duration in min> TIMEOUT=<duration in min> OUTPUT_GCODE=<GCODE_MACRO>

# Your slicer start_gcode should be like this
# e.g Superslicer
#   HEATSEQ BED_TEMP=[first_layer_bed_temperature] EXTRUDER_TEMP={first_layer_temperature[initial_extruder]+extruder_temperature_offset[initial_extruder]-40} CHAMBER_TEMP=[chamber_temperature]
#   PRINT_START <YOUR_STUFF>

# You can also update sequence target and timeout when HEATSEQ is running
#   HEATSEQ CHAMBER_TEMP=55 CHAMBER_TEMP_TIMEOUT=20

#  If you need some actions to be done before heatseq put its in another macro
# e.g.
#    PREFLY
#    HEATSEQ <blahblahblah>
#    PRINT_START <blahblahblah>

#  OUTPUT_GCODE can be added as parameter. The template will be call at the end of HEATSEQ
# e.g.
#    HEATSEQ <blahblahblah> OUTPUT_GCODE=CASELIGHT_ON

#  SEQUENCE. By default HEATSEQ loads `heatsoak`, you can setup alternate sequences by name
#  e.g.
#    HEATSEQ SEQUENCE=preheat_hotend_abs

# The HEATSEQ sequences are defined in _HS_VARIABLES macro (see example below)
# each sequence entry must contain a type (temp, pwm, timer) and a sensor name (e.g. heater_bed, extruder, temperature_sensor chamber)
# It may also contain an offset_temp (a temp offset to trigger after/before the target) and timeout and target
# ! IMPORTANT ! : Set the sensor values according to your printer configuration

# The order of sequence can be changed or removed but setting bed_power before bed_temp could be funny XD
# available sequence items type:
#   heat : set heater target temperature and wait to reach it (heaters only)
#     !! `heat` is a breaking change if you use previous version of this heatseq, you'd
#     probably need to change `temp` type to `heat` for bed, extruder, ... 
#   temp : wait to reach target temperature (any temp sensor)
#   pwm : wait for PWM stability (Experimental)
#   timer : wait for X minutes

# Sequences
[gcode_macro _HS_VARIABLES]
#Sequence table: item parameters are 
# 'type' = heat, temp, tempramp, pwm, timer (required)
# 'sensor' = temperature sensor ref (required)
# 'offset_temp' = the offset temperature +/- that trigger
# 'timeout' = max time to wait, default 0, 30min for heaters
# 'target' = target (minutes or temperature °C )
# 'speed' = for 'tempramp' type only, heating speed in °C/min
# 'pre/post_gcode' = command runned before/after sequence item
variable_hs_allow_standalone: True  #To manually use HEATSEQ outside a print job
variable_heatsoak: {'bed_temp':{'type': 'heat',
                                'sensor': 'heater_bed',
                                'offset_temp': 1,
                                'timeout': 30 },
                    'bed_power':{'type': 'pwm',
                                'sensor': 'heater_bed'},
                    'chamber_temp':{'type': 'temp',
                                'sensor': 'temperature_sensor chamber'},
                    'extruder_temp':{'type': 'heat',
                                'sensor': 'extruder',
                                'timeout' : 30 }}
variable_relax_abs: {'release':{'type': 'heat',
                                'sensor': 'heater_bed',
                                'timeout' : 30,
                                'target' : 60 },
                    'release_time':{'type': 'timer',
                                'target':3},
                    'destress':{'type': 'tempramp',
                                'sensor': 'heater_bed',
                                'timeout' : 30,
                                'target' : 110,
                                'speed': 3 },
                    'destress_time':{'type': 'timer',
                                'target':5 ,
                                'post_gcode': 'TURN_OFF_HEATERS'}}
variable_verbose: False
gcode:

[gcode_macro HEATSEQ]
description: Printer warmup sequence
variable_interval: 0.5
variable_soak_pending: False
variable_soak: {}
variable_current_timer: 0
variable_start_time: 0
variable_total_timer:0
variable_sequence: {}
gcode:
    {% set _uv = printer['gcode_macro _HS_VARIABLES'] %}

    {% macro update_sequence() %}
        {% for item in sequence %}
            {% set _= sequence[item].update({
                'target' : params[item|upper]
                            |default(sequence[item].target)
                            |default(0)|float
                }) %}
            {% set _= sequence[item].update({
                'timeout' : sequence[item].target if sequence[item].type == "timer" else
                            params["%s_TIMEOUT" % item|upper]
                            |default(sequence[item].timeout)
                            |default(soak.timeout)|int,
                }) %}             
        {% endfor %}
    {% endmacro %} 

    {% set _sequence_name = params["SEQUENCE"] %}
    {% if params.SEQUENCE is defined and _uv[_sequence_name] is not defined %}
        {action_raise_error("Sequence %s doesn't exist, Check _HS_VARIABLES" % _sequence_name)}
    {% endif %}
    {% set _sequence = _uv[_sequence_name]|default(_uv.heatsoak) %}
    {% set _= soak.update({'timeout' : params.TIMEOUT|default(30)|int }) %} #Timeout can be set in Params Entries or in sequence object, default 30 min
    {% set is_printing = printer.print_stats.state in ["printing","paused"] %}

    {% if soak_pending %}
        # sequence target and timeout
        { update_sequence() }

    {% else %}
        {% if is_printing or _uv.hs_allow_standalone %}
            # Start Heat sequence
            SET_GCODE_VARIABLE MACRO=HEATSEQ VARIABLE=soak_pending VALUE=True #HEATSEQ status, prevent to call it twice          
            # Init sequence and update target from entry params (e.g. HEATSEQ BED_TEMP=80 gives sequence.bed_temp.target=80)
            {% set _= soak.update({'current_seq': 'start',
                                    'end_gcode': params.OUTPUT_GCODE|default(''),
                                    'print_mode': is_printing }) %}
            {% set _= sequence.clear() %}
            {% set _= sequence.update(_sequence.copy()) %}
            { update_sequence() }

            # Set idle timeout according sequence timeouts.
            SET_IDLE_TIMEOUT TIMEOUT={(sequence.values()|sum(attribute='timeout')*60,printer.configfile.settings.idle_timeout.timeout)|max }

            _HS_RESPOND MSG="Entering heating sequence {_sequence_name} !" 

            {% if is_printing %} 
                # from gcode file: 
                _HS_RESPOND MSG="Use HEATSEQ_NEXT / HEATSEQ_CANCEL or RESUME to interact"

                G4 P1800 # Wait before pausing to let Moonraker catch printing status FIXED : 10/03/2022
                M400     # Fix to avoid klipper overload
                
                {% if printer.configfile.settings['gcode_macro pause'] is defined %}
                    {printer.configfile.settings['gcode_macro pause'].rename_existing }
                {% else %}
                    PAUSE
                {% endif %}
                
                _HS_NEXT # initiate "LOOP"   
            {% else %}
                # from macro: Advertise SA mode !
                CLEAR_PAUSE  #clear pause status to avoid mistake if a print is started during standalone mod
                _HS_RESPOND MSG="<span class="warning"--text>!WARNING! HEATSEQ run in standalone mode</span>\\nuse HEATSEQ_NEXT / HEATSEQ_CANCEL to interact\\n <span class="warning"--text>IT CANNOT BE USED INSIDE A MACRO</span>"
                _HS_NEXT # initiate "LOOP"
            {% endif %}

        {% elif not _uv.hs_allow_standalone %}
            # from macro: throw error
            {action_raise_error("HEATSEQ is not allowed in standalone mode")}
        {% endif %}
    {% endif %}

# Wait bed reach target temperature (Async, can be interrupt)
[delayed_gcode _HEATSEQ_CHECK]
gcode:
    {% set _hs = printer['gcode_macro HEATSEQ'] %}
    {% set _hs_seq = _hs.sequence[_hs.soak.current_seq] %}
    {% set _delayed_msg = printer['gcode_macro _RESPOND_DELAYED'].dat %}

    {% if _hs.soak_pending %}
        # Update timer and display MSG if verbose
        SET_GCODE_VARIABLE MACRO=HEATSEQ VARIABLE=current_timer VALUE={(printer.toolhead.estimated_print_time - _hs.start_time)|int}
        {% if _hs.current_timer|int % 10 == 0 and _delayed_msg.lasttime|int != _hs.current_timer|int and _delayed_msg.msg != "0" %}
            _HS_RESPOND VERBOSE=True MSG="{_delayed_msg.msg}"
            _RESPOND_DELAYED MSG=0 TIME={_hs.current_timer}
        {% endif %}

        {% if (_hs.soak.print_mode and not printer.pause_resume.is_paused) %}
            HEATSEQ_CANCEL
        {% elif _hs.soak.reached %}
            _HEATSEQ_INTERRUPT
        {% elif _hs.current_timer >= _hs_seq.timeout*60 %}
            _HS_RESPOND MSG="{ "%s interrupt after %smin %ss" % (_hs.soak.current_seq,(_hs.current_timer/60)|int,(_hs.current_timer%60)|int) }"
            _HS_NEXT
        {% else %}
            UPDATE_DELAYED_GCODE ID=_HEATSEQ_CHECK DURATION={_hs.interval}
            {% if '_' + _hs_seq.type|upper in printer.gcode.commands %}
                _{ _hs_seq.type }   
            {% else %}
                { action_raise_error('_%s does not exist' % (_hs_seq.type)) }
            {% endif %}
        {% endif %}
    {% endif %}

# HEATSEQ next item in sequence
[gcode_macro HEATSEQ_NEXT]
description: Skip current item in sequence
gcode:
    {% set _hs = printer['gcode_macro HEATSEQ'] %}
    {% set _interrupt= "_%s_interrupt" % _hs.sequence[_hs.soak.current_seq].type %} 
    { _interrupt if _interrupt|upper in printer.gcode.commands else "" }
    _HS_NEXT

[gcode_macro _HS_NEXT]
gcode:
    {% set _hs = printer['gcode_macro HEATSEQ'] %}
    {% if _hs.soak_pending %}
        SET_GCODE_VARIABLE MACRO=HEATSEQ VARIABLE=total_timer VALUE={_hs.total_timer + _hs.current_timer}
        SET_GCODE_VARIABLE MACRO=HEATSEQ VARIABLE=start_time VALUE={printer.toolhead.estimated_print_time}
        SET_GCODE_VARIABLE MACRO=HEATSEQ VARIABLE=current_timer VALUE=0
        _RESPOND_DELAYED MSG=0     
        {% set _=  _hs.soak.update({'reached': True}) %}
        SET_GCODE_VARIABLE MACRO=HEATSEQ VARIABLE=soak VALUE="{_hs.soak|string}"
        UPDATE_DELAYED_GCODE ID=_HEATSEQ_CHECK DURATION=0.1
    {% endif %}
    
#  HEATSEQ wait interruption (async)
[gcode_macro _HEATSEQ_INTERRUPT]
gcode:
    {% set _hs = printer['gcode_macro HEATSEQ'] %}
    {% if _hs.soak_pending %}
        {% for seq in _hs.sequence %}
            {% if _hs.soak.reached and (seq == _hs.soak.current_seq or _hs.soak.current_seq == 'start') %}
                { _hs.sequence[seq].post_gcode|default('') }
            # Exit HEATSEQ : Last item target reached 
                {% if loop.last and _hs.soak.current_seq != 'start' %}
                    
                    _HS_RESPOND MSG="{"HEATSEQ Total duration : %smin %ss" % (((_hs.total_timer)/60)|int,((_hs.total_timer)%60)|int) }"

                    {_hs.soak.end_gcode}
                    {% if printer.pause_resume.is_paused %}
                        # Use Klipper resume command
                        SAVE_GCODE_STATE NAME=PAUSE_STATE # reset gcode state before resuming
                        M400
                        G4 P200
                        {% if printer.configfile.settings['gcode_macro resume'] is defined %}
                            {printer.configfile.settings['gcode_macro resume'].rename_existing }
                        {% else %}
                            RESUME
                        {% endif %}
                    {% endif %}
                    #Reset parameters
                    HEATSEQ_CANCEL
            # Continue HEATSEQ : previous item target reached    
                {% else %}
                    # Set next sequence
                    {% set _= _hs.soak.update({'current_seq' : seq if _hs.soak.current_seq == 'start' else loop.nextitem, 'reached': False}) %}
                    {% set current_seq = _hs.sequence[_hs.soak.current_seq] %}

                    # Reset current sequence
                    {% if printer['gcode_macro _' + current_seq.type + '_reset'] is defined %}
                        _{current_seq.type}_reset seq={_hs.soak.current_seq}
                    {% endif %}
                    { current_seq.pre_gcode|default('') }
                    {% if current_seq.type == 'timer' %}
                        _HS_RESPOND MSG='HEATSEQ: `{_hs.soak.current_seq}` timer: {current_seq.target} min'
                    {% elif current_seq.type in ['heat','temp'] %}
                        _HS_RESPOND MSG='HEATSEQ: `{_hs.soak.current_seq}` target: {current_seq.target|default(_hs.soak.target)}°C, timeout: {current_seq.timeout} min'
                    {% elif current_seq.type == 'pwm' %}
                        _HS_RESPOND MSG='HEATSEQ: `{_hs.soak.current_seq}` check pwm, timeout: {current_seq.timeout} min'
                    {% elif current_seq.type == 'tempramp' %}
                        _HS_RESPOND MSG='HEATSEQ: `{_hs.soak.current_seq}` target: {current_seq.target|default(_hs.soak.target)}°C at {current_seq.speed|default(1)}°C/min, timeout: {current_seq.timeout} min'
                    {% endif %}
                {% endif %}
            {% endif %}
        {% endfor %}
        SET_GCODE_VARIABLE MACRO=HEATSEQ VARIABLE=soak VALUE="{_hs.soak|string}"
        UPDATE_DELAYED_GCODE ID=_HEATSEQ_CHECK DURATION=0.1
    {% endif %}

# Cancel heatseq (async only)
[gcode_macro HEATSEQ_CANCEL]
description: Cancel HEATSEQ
gcode:
    SET_GCODE_VARIABLE MACRO=HEATSEQ VARIABLE=soak_pending VALUE=False
    SET_GCODE_VARIABLE MACRO=HEATSEQ VARIABLE=current_timer VALUE=0
    SET_GCODE_VARIABLE MACRO=HEATSEQ VARIABLE=total_timer VALUE=0
    UPDATE_DELAYED_GCODE ID=_HEATSEQ_CHECK DURATION=0
    SET_IDLE_TIMEOUT TIMEOUT={printer.configfile.settings.idle_timeout.timeout}
    {% if printer['gcode_macro HEATSEQ'].soak_pending %}
    _HS_RESPOND MSG="End of heating sequence !"
    {% endif %}

# wait temp
[gcode_macro _temp]
variable_startup_value : 0
gcode:
    {% set _hs = printer['gcode_macro HEATSEQ'] %}
    {% if _hs.soak_pending %}
        {% set _hs_seq = _hs.sequence[_hs.soak.current_seq] %}
        
        # check if temperature if reached
        {% if printer[_hs_seq.sensor].temperature < (_hs_seq.target|default(0)|int - _hs_seq.offset_temp|default(0)|int) 
            or (printer[_hs_seq.sensor].temperature > (_hs_seq.target|default(0)|int + _hs_seq.offset_temp|default(0)|int) + 1 
            and _hs_seq.type in ["heat","ramptemp"] and _hs_seq.target|default(0)|int != 0 ) %}
            _RESPOND_DELAYED MSG="{_hs.soak.current_seq}/target {printer[_hs_seq.sensor].temperature}°C/{_hs_seq.target}°C"
        {% else %}
            _HS_RESPOND MSG="{_hs.soak.current_seq}: {_hs_seq.sensor} reached {printer[_hs_seq.sensor].temperature}°C from {startup_value}°C in {"%smin%ss" % ((_hs.current_timer/60)|int,(_hs.current_timer%60)|int)}"
            _HS_NEXT
        {% endif %}
    {% endif %}

# _temp interruption msg
[gcode_macro _temp_interrupt]
gcode:
    {% set _hs = printer['gcode_macro HEATSEQ'] %}
    {% set _hs_seq = _hs.sequence[_hs.soak.current_seq] %}
    _HS_RESPOND MSG="{_hs.soak.current_seq} interrupted after {"%smin%ss" % ((_hs.current_timer/60)|int,(_hs.current_timer%60)|int)}. {_hs_seq.sensor} at {printer[_hs_seq.sensor].temperature}°C"

# reset temp variables
[gcode_macro _temp_reset]
gcode:
    {% set _hs_seq = printer['gcode_macro HEATSEQ'].sequence[params.SEQ] %}
    SET_GCODE_VARIABLE MACRO=_temp VARIABLE=startup_value VALUE={printer[_hs_seq.sensor].temperature}

#Set heater temperature
[gcode_macro _heat]
gcode:
    {% set _hs = printer['gcode_macro HEATSEQ'] %}
    {% if _hs.soak_pending %}
        {% set _hs_seq = _hs.sequence[_hs.soak.current_seq] %}
        
        # if heater detected set temperature
        {% if printer[_hs_seq.sensor].target is defined %}
            {% if printer[_hs_seq.sensor].target != _hs_seq.target and _hs_seq.target != 0 %}
                SET_HEATER_TEMPERATURE HEATER='{_hs_seq.sensor.split(' ')|last}' TARGET={_hs_seq.target}
            {% endif %}
        {% endif %}
        _temp
    {% endif %}

[gcode_macro _heat_interrupt]
gcode:
    _temp_interrupt

# reset temp variables
[gcode_macro _heat_reset]
gcode:
    _temp_reset seq={params.SEQ}

[gcode_macro _tempramp]
variable_startup_value : 0
variable_speed: 1
gcode:
    {% set _hs = printer['gcode_macro HEATSEQ'] %}
    {% if _hs.soak_pending %}
        {% set _hs_seq = _hs.sequence[_hs.soak.current_seq] %}
        {% if printer[_hs_seq.sensor].target != _hs_seq.target %}
            {% set target_array = [startup_value + (speed *_hs.current_timer), _hs_seq.target] %}
            {% set target = target_array|min if speed > 0 else target_array|max %}
            {% if printer[_hs_seq.sensor].target != target and target != 0 %}
                SET_HEATER_TEMPERATURE HEATER='{_hs_seq.sensor.split(' ')|last}' TARGET={(target*100) | int / 100}
            {% endif %}
        {% else %}
            _temp
        {% endif %}
    {% endif %}

[gcode_macro _tempramp_interrupt]
gcode:
    _temp_interrupt

# reset temp variables
[gcode_macro _tempramp_reset]
gcode:
    {% set _hs_seq = printer['gcode_macro HEATSEQ'].sequence[params.SEQ] %}
    {% set start_value = printer[_hs_seq.sensor].temperature if printer[_hs_seq.sensor].target == 0 else printer[_hs_seq.sensor].target %}
    {% set delta_temp = _hs_seq.target - start_value %}
    {% set speed = _hs_seq.speed|default(1)|abs * delta_temp|abs / delta_temp / 60 %}
    SET_GCODE_VARIABLE MACRO=_tempramp VARIABLE=startup_value VALUE={start_value}
    SET_GCODE_VARIABLE MACRO=_tempramp VARIABLE=speed VALUE={speed}
    _temp_reset seq={params.SEQ}

# Compute smoothed quadratic derivative of pwm
# based on Savitzky-Golay algorithm
[gcode_macro _pwm]
variable_buffer: []   #stored power values
variable_d: {'val': 100,'stable': 0,'stable_value':0}
gcode:
    {% set _hs = printer['gcode_macro HEATSEQ'] %}
    {% if _hs.soak_pending %}
        {% set _hs_seq = _hs.sequence[_hs.soak.current_seq] %}

        # Populate buffer
        {% set pow= printer[_hs_seq.sensor].power|float %}
        {% set _= buffer.append(pow) %}
        {% if buffer|length > 125 %}  #max_vals
            {% set _= buffer.pop(0) %}
        {% endif %}

        {% if buffer|length > 15 %}  #min_vals
            {% set _=d.update({'val':0}) %}
        # normalize sample (size should be odd number)
            {% set half_window = ((buffer|length -1 )/2)|int %}
            {% set window_size = half_window*2 +1 %}
            {% set inc = 1 - (buffer|length % 2) %}  # 0 for odd, 1 for even
            {% set norm = (window_size - 1) * window_size * (window_size + 1) * printer['gcode_macro HEATSEQ'].interval %}  # Normalization factor

        # Compute Smoothed Quadratic derivative of center value
            {% for i in range(window_size) %}
                {% set _=d.update({'val':0 + d.val + buffer[i + inc]*(i-half_window)/norm}) %}
            {% endfor %}

            _RESPOND_DELAYED MSG="{_hs.soak.current_seq} variation {"%.2f" % (d.val*6000)}%/min, nb of samples: {window_size}" 
        {%endif %}
        
        # Test if stability is reached (4 times under "stability")
        {% if d.val|abs < 7E-6 %} #stability
            {% set _= d.update({'stable': (d.stable + 1), 'stable_value': (d.stable_value*d.stable + d.val|abs )/( d.stable + 1 )}) %}
            {% if d.stable > 3 %} #stability_times          
                _HS_RESPOND MSG="{_hs.soak.current_seq} stabilized {"%.2f" % (d.stable_value*6000)}%/min in {"%smin%ss" % ((_hs.current_timer/60)|int,(_hs.current_timer%60)|int)}"
                #reset stabilized sample count
                {% set _= d.update({'stable': 0, 'stable_value' : 0 }) %}
                _HS_NEXT
            {% endif %}
        {% else %}
            #reset stabilized sample count
            {% set _=d.update({'stable': 0, 'stable_value' : 0 }) %}
        {% endif %}   
    {% endif %}

[gcode_macro _pwm_interrupt]
gcode:
    {% set _hs = printer['gcode_macro HEATSEQ'] %}
    {% set d = printer["gcode_macro _pwm"].d %}
    _HS_RESPOND MSG="{_hs.soak.current_seq} interrupted after {"%smin%ss" % ((_hs.current_timer/60)|int,(_hs.current_timer%60)|int)}. Current pwm slope : {"%.2f" % (d.val*6000)}%/min"

# reset _pwm variables
[gcode_macro _pwm_reset]
gcode:
    SET_GCODE_VARIABLE MACRO=_pwm VARIABLE=buffer VALUE='[]'
    SET_GCODE_VARIABLE MACRO=_pwm VARIABLE=d VALUE='{ {'val': 100, 'duration': 0, 'stable': 0}|tojson }'

[gcode_macro _timer]
gcode:
    {% set _hs = printer['gcode_macro HEATSEQ'] %}
    {% set _hs_seq = _hs.sequence[_hs.soak.current_seq] %}
    {% if _hs.current_timer|float/60 <= _hs_seq.target %}
        _RESPOND_DELAYED MSG="{_hs.soak.current_seq}: {"%smin%ss" % ((_hs.current_timer/60)|int,(_hs.current_timer%60)|int)} elapsed over {_hs_seq.target}min"
    {% else %}
        _HS_RESPOND MSG="{_hs.soak.current_seq}: {"%smin%ss" % ((_hs.current_timer/60)|int,(_hs.current_timer%60)|int)} elapsed"
        _HS_NEXT
    {% endif %}

[gcode_macro _timer_interrupt]
gcode:
    {% set _hs = printer['gcode_macro HEATSEQ'] %}
    _HS_RESPOND MSG="{_hs.soak.current_seq} timer interrupted after {"%smin%ss" % ((_hs.current_timer/60)|int,(_hs.current_timer%60)|int)}"

[gcode_macro _HS_RESPOND]
description: Helper:Display message in console (verbose mode)
gcode:
    {% set verbose = (params.VERBOSE|lower == 'true') | default(False) %}
    {% if not verbose or printer['gcode_macro _HS_VARIABLES'].verbose %}
        {action_respond_info(params.MSG | default("") | replace('\\n','\n'))}
    {% endif %}

[gcode_macro _RESPOND_DELAYED]
variable_dat : {'msg':'0','lasttime':0}
gcode:
    {% set _= dat.update({'msg':params.MSG, 'lasttime': params.TIME|default(dat.lasttime) }) %}
